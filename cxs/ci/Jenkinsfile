#!groovy

def dockerfile= 'dockerfile'

def getUserUid() {
    return sh(returnStdout: true, script: 'id -u').trim()
}

def build(name, file = 'cxs/ci/ubuntu.dockerfile cxs/ci', customParams = '') {
    return docker.build("$name-test", "--build-arg uid=${getUserUid()} -f $file")
}

node('ubuntu') {
    try {
        stage ('Checkout'){
            checkout scm
        }
        app = buildDocker()
        buildRust(app)
        updateVersions(app)
        testNodeWrapper(app)
        createDeb(app)
        // // createZip(app)
        // createNpmDeb(app) 
    } catch (Exception ex) {
        currentBuild.result = "FAILED"
        if (env.BRANCH_NAME == "master") {
            fail()
        }
        echo "$ex error"
    } finally {
        step([$class: 'WsCleanup'])
    }
}

def buildDocker(){
    def app
    def pathToCi = 'cxs/ci'
    stage ('Build docker environment'){
        sh "pwd"
        sh "ls ${pathToCi}"
        sh "echo building"
        app = build('cxs')
    }
    return app
}

def buildRust(envn){
    stage ('Building and Testing Rust Library'){
        envn.inside {
            sh "ls -l"
            sh "rustc --version"
            sh "gcc --version"
            sh "mkdir -p cxs/wrappers/node/lib"
            sh "ls -l"
            sh "cd cxs/libcxs; cargo test -- --test-threads=1"
            sh "cp cxs/libcxs/target/debug/libcxs.so cxs/wrappers/node/lib/"
            sh "ls cxs/wrappers/node/lib"
        }
    }
}

def testRust(envn) {
    stage ('Testing Rust'){
        sh "echo Testing"
        envn.inside {
            sh "cd cxs/libcxs; cargo test -- --test-threads=1"
        }
    }
}


def createZip(envn) {
    dir ('cxs/libcxs/target/debug'){
        stage ('Create TAR.GZ File') {
            envn.inside {
                sh 'cd cxs/libcxs/target/debug; tar -zvcf libcxs.tar.gz libcxs.so'
                archiveArtifacts allowEmptyArchive: true, artifacts: 'libcxs.tar.gz'
            }
        }
    }
}


// updates the path to include the scripts, 
// needed for cargo commands
def updatePath(app) {
    dir ('cxs/ci/scripts') {
        app.inside {
            sh 'export PATH=$PATH:`pwd`'
        }
    }
}


// Update the version and revision in the Cargo.toml file, also the so file .
def updateVersions(app) {
        stage('Updating Versions') {
            app.inside {
                sh 'ls -l'
                sh 'cd cxs/libcxs; ls -l; ls ../ci/scripts'
                sh 'cd cxs/libcxs; python ../ci/scripts/cargo-update-version'
                sh 'cd cxs/libcxs; python ../ci/scripts/cargo-update-so'
            }
        }
}


// Creates the debian package for the library, as well as gzips the libcxs.so.<version> file
// Publishes both artifacts.
def createDeb(envn) {
  stage('Build Libcxs Debian') {
      envn.inside {
        SCRIPT = '../ci/scripts/gzip_so_file.py'
        SO_FILE = 'target/debug/libcxs.so'
        sh 'cd cxs/libcxs/; cargo deb --no-build'
        archiveArtifacts allowEmptyARchive: true, artifacts: "cxs/libcxs/target/debian/libcxs_*_amd64.deb"
        sh "cd cxs/libcxs/; python ${SCRIPT} ${SO_FILE}"
        archiveArtifacts allowEmptyARchive: true, artifacts: "cxs/libcxs/target/debug/libcxs.so.*"
      }
  }
}

def testNodeWrapper(envn) {
    dir ('cxs/wrappers/node'){
        stage ('Test Node Wrapper'){
            envn.inside {
                sh 'ls -l lib'
                sh 'npm -v'
                sh 'npm install'
                sh 'npm rebuild'
                sh 'npm run lint'
                sh 'npm run compile'
                sh 'npm test'
            }
        }
//        stage ('Build Npm Tar'){
//            envn.inside {
//                if (env.BRANCH_NAME == "master") {
//                    sh 'npm pack'
//                    sh 'ls'
//                    sh "test -f cxs-${version}.tgz"
//                    archiveArtifacts allowEmptyArchive: true, artifacts: '**/*.tgz'
//                }
//            }
//        }
    }
}

def fail() {

    def message = [
        message: "$JOB_NAME - Build # $BUILD_NUMBER - fail: Check console output at $BUILD_URL to view the results."
    ]

    slackSend message

}

