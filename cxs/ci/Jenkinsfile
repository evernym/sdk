#!groovy

def dockerfile= 'dockerfile'

def getUserUid() {
    return sh(returnStdout: true, script: 'id -u').trim()
}

// docker build -t libcxs-test --build-arg uid=1001 -f cxs/ci/ubuntu.dockerfile cxs/ci
def build(name, file='cxs/ci/ubuntu.dockerfile', context='cxs/ci', customParams = '') {
    return docker.build("$name-test", "--build-arg uid=${getUserUid()} -f $file $context")
}

// docker build -t wrapper-test --build-arg uid=1001 -f cxs/ci/Dockerfile-wrapper-testing
def build_wrapper_testing_image(file='cxs/ci/Dockerfile-wrapper-testing', context='cxs', customParams = ''){
	return docker.build("wrapper-test", "--build-arg uid=${getUserUid()} -f $file $context")
}

node('ubuntu') {
    try {
        stage ('Checkout'){
            checkout scm
        }
        
        app = build('libcxs', 'cxs/ci/ubuntu.dockerfile', 'cxs/ci')
		
        // update the versions in the toml file and package.json
        updateVersions(app)      
        
        // build and test the so file
        buildRust(app)

	// test rust
	testRust(app)

        // update the so file to have version
        updateSo(app)
        // test the npm package and create the npm gzip artifact
        wrapper = build_wrapper_testing_image('cxs/ci/Dockerfile-wrapper-testing', 'cxs')
        testNodeWrapper(wrapper)
        if (env.BRANCH_NAME == "master") {
            // create the debian of the library
            createDeb(app)
            // create the npm deb 
            createNpmDeb(app) 
        }
        
    } catch (Exception ex) {
        currentBuild.result = "FAILED"
        if (env.BRANCH_NAME == "master") {
            fail()
        }
        echo "$ex error"
    } finally {
        step([$class: 'WsCleanup'])
    }
}

def buildDocker(){
    def app
    def pathToCi = 'cxs/ci'
    stage ('Build docker environment'){
        sh "pwd"
        sh "ls ${pathToCi}"
        sh "echo building"
        app = build('cxs')
    }
    return app
}

def buildRust(envn){
    stage ('Building and Testing Rust Library'){
        envn.inside {
            sh "ls -l"
            sh "rustc --version"
            sh "gcc --version"
            // sh "cd cxs/libcxs; cargo test -- --test-threads=1"
            sh "cd cxs/libcxs; cargo build --features ci"
        }
    }
}

def testRust(envn) {
    stage ('Testing Rust'){
        sh "echo Testing"
        envn.inside {
            sh "cd cxs/libcxs; cargo test --color never -- --test-threads=1"
        }
    }
}


// updates the path to include the scripts, 
// needed for cargo commands
def updatePath(app) {
    dir ('cxs/ci/scripts') {
        app.inside {
            sh 'export PATH=$PATH:`pwd`'
        }
    }
}


// Update the version and revision in the Cargo.toml file, also the so file .
def updateVersions(app) {
        stage('Updating Versions') {
            app.inside {
                sh 'ls -l'
                // TODO fix this ... these *SHOULD* be cargo commands.
                sh 'cd cxs/libcxs; ls -l; ls ../ci/scripts'
                sh 'cd cxs/libcxs; python ../ci/scripts/cargo-update-version'

            }
        }
}

def updateSo(app) {
    stage('Updating .so file version') {
        app.inside {
            sh 'cd cxs/libcxs; python ../ci/scripts/cargo-update-so'
        }
    }
}


// Creates the debian package for the library, as well as gzips the libcxs.so.<version> file
// Publishes both artifacts.
def createDeb(envn) {
    stage('Build libcxs Debian and compress .so file') {
        envn.inside {
            CERT_SCRIPT = 'cxs/ci/scripts/getCert.sh'
            SCRIPT = 'cxs/ci/scripts/gzip_so_file.py'
            FILES = 'cxs/libcxs/target/debug/libcxs.so.* cxs/libcxs/scripts/provision_agent_keys.py'
            DEST = 'libcxs.tar.gz'

            // get Evernym Certificate onto machine
            sh "${CERT_SCRIPT}"
                
            // build debian
            sh 'cd cxs/libcxs/; cargo deb --no-build'
    

            if (env.BRANCH_NAME == "master") {
                // archive debian to Jenkins
                archiveArtifacts allowEmptyARchive: true, artifacts: "cxs/libcxs/target/debian/libcxs_*_amd64.deb"

                // archive .so file to Jenkins
                sh "python ${SCRIPT} ${FILES} ${DEST}"
                archiveArtifacts allowEmptyARchive: true, artifacts: DEST

                // upload debian to Repo
                withCredentials([usernameColonPassword(credentialsId: 'jenkins-kraken-svc', variable: 'KRAKEN_CREDENTIALS')]) {
                    sh "find cxs/libcxs/target/debian/ -type f -name 'libcxs_*_amd64.deb' -exec curl --cacert /tmp/cert/ca.crt -u \"${KRAKEN_CREDENTIALS}\" -X POST https://kraken.corp.evernym.com/repo/agency_dev/upload -F file=@{} \\;"
                }
            }
        }
    }
}


// Creates the tgz file that can be 'npm install'-ed.
def testNodeWrapper(envn) {
    dir ('cxs/wrappers/node'){
        stage ('Test Node Wrapper'){
		    envn.inside {
    			sh 'npm -v'
	            sh 'npm install'
	            sh 'npm rebuild'
	            sh 'npm run lint'
	            sh 'npm run compile'
	            sh 'npm test'
	            sh 'ls -l'
			    sh 'npm pack'
	            sh 'ls'
	            sh "test -f cxs-*.tgz"
	            archiveArtifacts allowEmptyArchive: true, artifacts: '**/*.tgz'
      	    }
        }
    }
}


// Creates debian that can install through npm.
def createNpmDeb(app){
  dir('cxs') {
    stage ('Create Npm Deb') {
      app.inside {
        // TODO make this a version number from the script somehow.
        sh 'ls'
        sh 'python ci/scripts/create_npm_deb.py wrappers/node/cxs-*.tgz'
        sh 'ls'
        archiveArtifacts allowEmptyArchive: true, artifacts: 'cxs*.deb'
      }
    }
  }
}

def fail() {
    def message = [
        message: "$JOB_NAME - Build # $BUILD_NUMBER - fail: Check console output at $BUILD_URL to view the results."
    ]
    slackSend message
}

